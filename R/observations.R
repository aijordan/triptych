#' Accessing original forecast and observation data for triptych objects
#'
#' @param x An object from which the relevant information should be extracted.
#' @param ... Additional arguments passed to other methods.
#'
#' @return
#' For `forecasts()`: A tibble of the original forecasts in long format.
#'
#' For `observations()`: A vector of the observations.
#' 
#' @examples
#' data(ex_binary, package = "triptych")
#' tr <- triptych(ex_binary)
#' 
#' forecasts(tr)
#' observations(tr) 
#'
#' @seealso [estimates()], [regions()]
#' @name accessors
NULL

#' Accessing diagnostic estimate data
#'
#' @param x An object from which the estimate information should be extracted.
#' @param at A vector of thresholds where `x` should be evaluated.
#' @param ... Additional arguments passed to other methods.
#'
#' @return
#' A tibble with the relevant information describing
#'   the diagnostic estimate
#'   (Murphy curve, reliability curve, ROC curve, score decomposition)
#'   for all supplied forecasting methods.
#'   
#' For a Murphy curve, a tibble with columns: `forecast`, `knot` (the threshold value), `limit` ("left" or "right" in `knot`), `mean_score`.
#' 
#' For a reliability curve, a tibble with columns: `forecast`, `CEP`, `x` (the knots of the isotonic regression estimate).
#' 
#' For a ROC curve, a tibble with columns: `forecast`, `FAR` (false alarm rate), `HR` (hit rate).
#' 
#' For a MCBDSC decomposition, a tibble with columns: `forecast`, `mean_score`, `MCB` (miscalibration), `DSC` (discrimination), `UNC` (uncertainty).
#'   
#' @examples
#' data(ex_binary, package = "triptych")
#' tr <- triptych(ex_binary)
#' 
#' estimates(tr$murphy)
#' estimates(tr$reliability)
#' estimates(tr$roc)
#' estimates(tr$mcbdsc)
#'
#' @seealso [regions()], [forecasts()], [observations()]
#' @export
estimates <- function(x, at, ...) {
  UseMethod("estimates")
}

#' Accessing confidence/consistency region data
#'
#' @param x An object from which the region information should be extracted.
#' @param ... Additional arguments passed to other methods.
#'
#' @return
#' A tibble with the relevant information for the
#'   uncertainty quantification of the chosen diagnostic
#'   (Murphy curve, reliability curve, ROC curve, score decomposition)
#'   for all supplied forecasting methods.
#'   
#' For a Murphy curve, a tibble with columns: `forecast`, `threshold`, `lower`, `upper`, `method`, `level`.
#' 
#' For a reliability curve, a tibble with columns: `forecast`, `x` (forcast values), `lower`, `upper`, `method`, `level`.
#' 
#' For a ROC curve, a tibble with columns: `forecast`, `FAR` (false alarm rate), `HR` (hit rate), `method`, `level`.
#' This tibble is twice as long as those for Murphy and reliability curves,
#' since the FAR-HR pairs are ordered to describe a polygon, generated by pointwise confidence
#' intervals along diagonal lines with slope \eqn{-\pi_0/\pi_1}.
#' Here, \eqn{\pi_1 = 1 - \pi_0} is the unconditional event probability.
#'   
#' @examples
#' data(ex_binary, package = "triptych")
#' tr <- triptych(ex_binary) |>
#'   dplyr::slice(1, 9) |>
#'   add_confidence(level = 0.9, n_boot = 100)
#' 
#' regions(tr$murphy)
#' regions(tr$reliability)
#' regions(tr$roc)
#' regions(tr$mcbdsc)
#' 
#'
#' @seealso [estimates()], [forecasts()], [observations()]
#' @export
regions <- function(x, ...) {
  UseMethod("regions")
}
#' @rdname accessors
#' @export
forecasts <- function(x, ...) {
  UseMethod("forecasts")
}
#' @rdname accessors
#' @export
observations <- function(x, ...) {
  UseMethod("observations")
}

has_regions <- function(x, ...) {
  UseMethod("has_regions")
}

eval_diag <- function(x, at, ...) {
  UseMethod("eval_diag")
}

#' Adding confidence regions
#' 
#' Confidence regions are supposed to contain the true "parameter" with a given degree of confidence.
#' Here, "parameter" refers to a murphy curve, a reliability curve, or a ROC curve, respectively.
#'
#' @param x An object to which a confidence region should be added.
#' @param level A single value for the level of confidence.
#' @param method A string that gives the name of method to generate the confidence regions. Currently, one of: "resampling_cases", "resampling_Bernoulli".
#' @param ... Additional arguments passed to methods.
#' 
#' @return 
#' The object given to `x`, but with information about the confidence regions.
#' This information can be accessed conveniently by using [regions()] on the
#' curve component of interest.
#' 
#' @examples
#' data(ex_binary, package = "triptych")
#' 
#' # Construct triptych object and select 4 forecasts
#' tr <- triptych(ex_binary) |>
#'   dplyr::slice(1, 3, 6, 9)
#' 
#' tr <- add_confidence(tr, level = 0.9, n_boot = 100)
#' regions(tr$murphy)
#' regions(tr$reliability)
#' regions(tr$roc)
#' 
#' @export
add_confidence <- function(x, level, method, ...) {
  UseMethod("add_confidence")
}

#' Adding consistency regions for reliability curves
#' 
#' Consistency regions are created under the assumption that the forecasts are calibrated.
#' A reliability curve that significantly violates the consistency region indicates
#' a miscalibrated forecast.
#'
#' @param x An object to which a consistency region should be added.
#' @param level A single value for the level of confidence.
#' @param method A string that gives the name of method to generate the consistency regions. Currently, one of: "resampling_cases", "resampling_Bernoulli".
#' @param ... Additional arguments passed to methods.
#'
#' @return 
#' The object given to `x`, but with information about the consistency regions.
#' This information can be accessed conveniently by using [regions()] on the
#' reliability curve component.
#' 
#' @examples
#' data(ex_binary, package = "triptych")
#' 
#' # Construct triptych object (with reliability curve component) and select 4 forecasts
#' tr <- triptych(ex_binary) |>
#'   dplyr::slice(1, 3, 6, 9)
#' 
#' tr <- add_consistency(tr, level = 0.9, n_boot = 100)
#' regions(tr$reliability)
#' 
#' @export
add_consistency <- function(x, level, method, ...) {
  UseMethod("add_consistency")
}

has_compatible_observations <- function(x, y) {
  isTRUE(all.equal(observations(x), observations(y)))
}
